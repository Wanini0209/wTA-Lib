# -*- coding: utf-8 -*-
"""Unit-Tests related to `MaskedArray`."""

import numpy as np

from .._context import MaskedArray, array_equal

# pylint: disable=no-self-use, too-few-public-methods


class TestMaskedArray:
    """Tests related to builder of `MaskedArray`.

    """
    def test_always_copy_data(self):
        """Should always copy `data`.

        When the data array used to construct an instance of `MaskedArray`
        being modified, the data stored in the built object would not be
        changed.

        """
        data = np.arange(4)
        array = MaskedArray(data)
        cond_1 = array_equal(data, array.data)  # before being modified
        data[0] = data[1]
        cond_2 = array_equal(data, array.data)  # after being modified
        assert cond_1 and not cond_2

    def test_always_copy_masks(self):
        """Should always copy `masks`.

        When the mask array assigned to `masks` to construct an instance of
        `MaskedArray` being modified, the availability of elements of the
        built object would not be changed.

        """
        data = np.arange(4)
        masks = np.array([True, False, True, False])
        array = MaskedArray(data, masks)
        cond_1 = array_equal(masks, array.isna())  # before being modified
        masks[1] = ~masks[1]
        cond_2 = array_equal(masks, array.isna())  # before being modified
        assert cond_1 and not cond_2

    def test_without_na_by_default(self):
        """Return an instance of `MaskedArray` with expected content.

        When constructing without setting `masks`(By default), it should return
        an instance of `MaskedArray` in which all elements ara available.

        """
        data = np.arange(4)
        array = MaskedArray(data)
        answer = np.full(data.shape, False)
        assert array_equal(answer, array.isna())

    def test_with_specified_masks(self):
        """Return an instance of `MaskedArray` with expected content.

        When constructing with specified `masks`, it should return an instance
        of `MaskedArray` in which the non-availability of elements ara equal
        to the specified boolean array.

        """
        data = np.arange(4)
        masks = np.array([True, False, True, False])
        array = MaskedArray(data, masks)
        assert array_equal(masks, array.isna())


class TestData:
    """Tests related to `MaskedArray.data`.

    See Also
    --------
    TestMaskedArray

    """
    def test_always_return_a_copy(self):
        """Should always return a copy.

        When the array received from `data` of an instance of `MaskedArray`
        being modified, the content of the instance would not be changed.

        """
        array = MaskedArray(np.arange(4))
        recv = array.data
        recv[0] = recv[1]
        assert not array_equal(recv, array.data)


class TestDtype:
    """Tests related to `MaskedArray.dtype`.

    """
    def test_with_array_data(self):
        """Should return an expected object of `numpy.dtype`.

        When the data array used to construct an instance of `MaskedArray`,
        the `dtype` of the instance must be the same as the `dtype` of the
        data array.

        """
        data = np.array([1, 2, 3, 4])
        array = MaskedArray(data)
        assert data.dtype == array.dtype

    def test_with_list_data(self):
        """Should return an expected object of `numpy.dtype`.

        When the data list used to construct an instance of `MaskedArray`,
        the `dtype` of the instance must be the same as the `dtype` of the
        NumPy array generated by the same data list.

        """
        data = [1, 2, 3, 4]
        array = MaskedArray(data)
        assert np.array(data).dtype == array.dtype


class TestNdim:
    """Tests related to `MaskedArray.ndim`.

    """
    def test_with_array_data(self):
        """Should return an expected integer.

        When the data array used to construct an instance of `MaskedArray`,
        the `ndim` of the instance must be the same as the `ndim` of the
        data array.

        """
        data = np.array([[1, 2], [3, 4]])
        array = MaskedArray(data)
        assert data.ndim == array.ndim

    def test_with_nested_list_data(self):
        """Should return an expected integer.

        When the nested list data used to construct an instance of
        `MaskedArray`, the `ndim` of the instance must be the same as the
        `ndim` of the NumPy array generated by the same nested list data.

        """
        data = [[1, 2], [3, 4]]
        array = MaskedArray(data)
        assert np.array(data).ndim == array.ndim


class TestShape:
    """Tests related to `MaskedArray.shape`.

    """
    def test_with_array_data(self):
        """Should return an expected tuple of integer.

        When the data array used to construct an instance of `MaskedArray`,
        the `shape` of the instance must be the same as the `shape` of the
        data array.

        """
        data = np.array([[1, 2], [3, 4]])
        array = MaskedArray(data)
        assert data.shape == array.shape

    def test_with_nested_list_data(self):
        """Should return an expected tuple of integer.

        When the nested list data used to construct an instance of
        `MaskedArray`, the `shape` of the instance must be the same as the
        `shape` of the NumPy array generated by the same nested list data.

        """
        data = [[1, 2], [3, 4]]
        array = MaskedArray(data)
        assert np.array(data).shape == array.shape


class TestLen:
    """Tests related to `len` on `MaskedArray`.

    """
    def test_with_array_data(self):
        """Should return an expected integer.

        When the data array used to construct an instance of `MaskedArray`,
        the reulst of `len` function to the instance must be the same as the
        result to the data array.

        """
        data = np.array([[1, 2], [3, 4]])
        array = MaskedArray(data)
        assert len(data) == len(array)

    def test_with_nested_list_data(self):
        """Should return an expected integer.

        When the nested list data used to construct an instance of
        `MaskedArray`, the reulst of `len` function to the instance must be the
        same as the result to the NumPy array generated by the same nested list
        data.

        """
        data = [[1, 2], [3, 4]]
        array = MaskedArray(data)
        assert len(np.array(data)) == len(array)


class TestIsNa:
    """Tests related to `MaskedArray.isna`.

    See Also
    --------
    TestMaskedArray

    """
    def test_without_specified_masks(self):
        """Return an expected NumPy boolean array.

        When call `isna` method on an instance of `MaskedArray`, which is
        constructed without specified `masks`, it should return a NumPy
        boolean array in which all elements are ``False``.

        """
        array = MaskedArray(np.arange(4))
        answer = np.full(array.shape, False)
        assert array_equal(answer, array.isna())

    def test_with_specified_masks(self):
        """Return an expected NumPy boolean array.

        When call `isna` method on an instance of `MaskedArray`, which is
        constructed with specified `masks`, it should return a NumPy
        boolean array equivalent to `masks`.

        """
        masks = [True, False, False, True]
        array = MaskedArray(np.arange(4), masks)
        answer = np.array(masks)
        assert array_equal(answer, array.isna())


class TestToNumpy:
    """Tests related to `MaskedArray.to_numpy`.

    """
    def test_without_specified_masks(self):
        """Return an expected NumPy array.

        When call `to_numpy` method on an instance of `MaskedArray` which is
        constructed without specified `masks`, it should return a NumPy
        array equivalent to `data`.

        """
        data = np.arange(4)
        array = MaskedArray(data)
        assert array_equal(data, array.to_numpy())

    def test_with_specified_masks_on_integer_data(self):
        """Return an expected NumPy array.

        When call `to_numpy` method on an instance of `MaskedArray` which is
        constructed with integer values as `data` and specified `masks`, it
        should return a NumPy float array equivalent to `data` but N/A elements
        (where the corresponding elements in `masks` are ``True``) replaced
        with ``np.nan``.

        """
        data = [1, 2, 3, 4]
        masks = [True, False, True, False]
        array = MaskedArray(data, masks)
        answer = np.array([np.nan, 2, np.nan, 4], float)
        assert array_equal(answer, array.to_numpy())

    def test_with_specified_masks_on_float_data(self):
        """Return an expected NumPy array.

        When call `to_numpy` method on an instance of `MaskedArray` which is
        constructed with float values as `data` and specified `masks`, it
        should return a NumPy float array equivalent to `data` but N/A elements
        (where the corresponding elements in `masks` are ``True``) replaced
        with ``np.nan``.

        """
        data = [1., 2., 3., 4.]
        masks = [True, False, True, False]
        array = MaskedArray(data, masks)
        answer = np.array([np.nan, 2., np.nan, 4.], float)
        assert array_equal(answer, array.to_numpy())

    def test_with_specified_masks_on_boolean_data(self):
        """Return an expected NumPy array.

        When call `to_numpy` method on an instance of `MaskedArray` which is
        constructed with boolean values as `data` and specified `masks`, it
        should return a NumPy array with object dtype, equivalent to `data`
        but N/A elements (where the corresponding elements in `masks` are
        ``True``) replaced with ``np.nan``.

        """
        data = np.array([True, True, False, False])
        masks = np.array([True, False, True, False])
        array = MaskedArray(data, masks)
        answer = np.array([np.nan, True, np.nan, False], object)
        assert array_equal(answer, array.to_numpy())


class TestEquals:
    """Tests related to `MaskedArray.equals`.

    """
    def test_against_another_with_same_contents(self):
        """Should return ``True``.

        Compare against another instance built with same `data` and `masks`.

        """
        data = np.array([1, 2, 3, 4])
        masks = np.array([True, False, True, False])
        target = MaskedArray(data, masks)
        reference = MaskedArray(data, masks)
        assert target.equals(reference)

    def test_against_another_built_with_same_data_and_equivalent_masks(self):
        """Should return ``True``.

        Compare against another instance built with same `data` and equivalent
        `masks`(one is not specified and another is specified as a boolean
        array in which all values are ``False``).

        """
        data = np.array([1, 2, 3, 4])
        masks = np.full(data.shape, False)
        target = MaskedArray(data)
        reference = MaskedArray(data, masks)
        cond_1 = target.equals(reference)
        cond_2 = reference.equals(target)
        assert cond_1 and cond_2

    def test_against_another_built_with_same_data_but_different_masks(self):
        """Should return ``False``.

        Compare with another instance built with same `data` but difference
        `masks`.

        """
        data = np.array([1, 2, 3, 4])
        masks = np.array([True, False, True, False])
        target = MaskedArray(data)
        reference = MaskedArray(data, masks)
        cond_1 = not target.equals(reference)
        cond_2 = not reference.equals(target)
        assert cond_1 and cond_2

    def test_against_another_with_same_available_elements(self):
        """Should return ``True``.

        Compare with another instance built with same `masks` and `data` only
        difference on the corresponding N/A elements.

        """
        masks = np.array([True, False, True, False])
        target = MaskedArray([1, 2, 3, 4], masks)
        reference = MaskedArray([0, 2, 0, 4], masks)
        cond_1 = target.equals(reference)
        cond_2 = reference.equals(target)
        assert cond_1 and cond_2

    def test_on_array_with_equal_but_difference_dtype_data(self):
        """Should return ``False``.

        Compare with another instance built with `data` containing equal values
        but different dtype.

        """
        data = np.array([1, 2, 3, 4])
        target = MaskedArray(data)
        reference = MaskedArray(data.astype(float))
        cond_1 = not target.equals(reference)
        cond_2 = not reference.equals(target)
        assert cond_1 and cond_2

    def test_on_non_masked_array_object(self):
        """Should return ``False``."""
        data = np.array([1, 2, 3, 4])
        target = MaskedArray(data)
        assert not target.equals(data)


class TestFillNa:
    """Tests related to `MaskedArray.fillna`.

    """
    def test_keep_the_calling_object_unchanged(self):
        """The contents of the calling object could not be changed.

        When call `fillna` method on an instance of `MaskedArray`, the
        contents of the calling object must remain unchanged.

        """
        data = np.array([1, 2, 3, 4])
        masks = np.array([True, False, True, False])
        array = MaskedArray(data, masks)
        recv = array.fillna(0)
        cond_1 = not np.array_equal(recv.data, array.data)
        cond_2 = array_equal(data, array.data)
        assert cond_1 and cond_2

    def test_on_array_with_na_elements(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `fillna` method with specified `value` on an instance of
        `MaskedArray` with N/A elements, it return a copy of the calling object
        with N/A elements filled using `value`.

        """
        masks = np.array([True, False, True, False])
        array = MaskedArray([1, 2, 3, 4], masks)
        result = array.fillna(0)
        answer = MaskedArray([0, 2, 0, 4])
        assert result.equals(answer)


class TestFfill:
    """Tests related to `MaskedArray.ffill`.

    """
    def test_keep_the_calling_object_unchanged(self):
        """The contents of the calling object could not be changed.

        When call `ffill` method on an instance of `MaskedArray`, the
        contents of the calling object must remain unchanged.

        """
        data = np.array([1, 2, 3, 4])
        masks = np.array([False, True, False, True])
        array = MaskedArray(data, masks)
        recv = array.ffill()
        cond_1 = not np.array_equal(recv.data, array.data)
        cond_2 = array_equal(data, array.data)
        assert cond_1 and cond_2

    def test_on_data_without_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `ffill` method on an instance of `MaskedArray` without
        N/A elements, it return a copy of the calling object.

        """
        data = np.array([1, 2, 3, 4])
        result = MaskedArray(data).ffill()
        answer = MaskedArray(data)
        assert result.equals(answer)

    def test_on_data_with_leading_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `ffill` method on an instance of `MaskedArray` with leading
        N/A elements, it return a copy of the calling object with non-leading
        N/A elements filled using forward-fill method and leading N/A elements
        keeping unavailable.

        """
        result = MaskedArray([1, 2, 3, 4], [True, False, True, False]).ffill()
        answer = MaskedArray([1, 2, 2, 4], [True, False, False, False])
        assert result.equals(answer)

    def test_on_data_without_leading_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `ffill` method on an instance of `MaskedArray` without
        leading N/A elements, it return a copy of the calling object with all
        N/A elements filled using forward-fill method.

        """
        result = MaskedArray([1, 2, 3, 4], [False, True, False, True]).ffill()
        answer = MaskedArray([1, 1, 3, 3])
        assert result.equals(answer)


class TestBfill:
    """Tests related to `MaskedArray.bfill`.

    """
    def test_keep_the_calling_object_unchanged(self):
        """The contents of the calling object could not be changed.

        When call `bfill` method on an instance of `MaskedArray`, the
        contents of the calling object must remain unchanged.

        """
        data = np.array([1, 2, 3, 4])
        masks = np.array([False, True, False, True])
        array = MaskedArray(data, masks)
        recv = array.bfill()
        cond_1 = not np.array_equal(recv.data, array.data)
        cond_2 = array_equal(data, array.data)
        assert cond_1 and cond_2

    def test_on_data_without_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `bfill` method on an instance of `MaskedArray` without
        N/A elements, it return a copy of the calling object.

        """
        data = np.array([1, 2, 3, 4])
        result = MaskedArray(data).bfill()
        answer = MaskedArray(data)
        assert result.equals(answer)

    def test_on_data_with_tailing_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `bfill` method on an instance of `MaskedArray` with tailing
        N/A elements, it return a copy of the calling object with non-tailing
        N/A elements filled using backward-fill method and tailing N/A elements
        keeping unavailable.

        """
        result = MaskedArray([1, 2, 3, 4], [False, True, False, True]).bfill()
        answer = MaskedArray([1, 3, 3, 4], [False, False, False, True])
        assert result.equals(answer)

    def test_on_data_without_tailing_nas(self):
        """Return an instance of `MaskedArray` with expected contents.

        When call `bfill` method on an instance of `MaskedArray` without
        tailing N/A elements, it return a copy of the calling object with all
        N/A elements filled using backward-fill method.

        """
        result = MaskedArray([1, 2, 3, 4], [True, False, True, False]).bfill()
        answer = MaskedArray([2, 2, 4, 4])
        assert result.equals(answer)


class TestSubscript:
    """Tests related to subscript operator of `MaskedArray`.

    """
    def test_subscript_by_boolean_array(self):
        """Return an instance of `MaskedArray` with expected contents.

        Return a copy of the calling object which content is equal to the
        result of making same subscript operator on the content of the calling
        object.

        """
        data = np.arange(10)
        masks = data % 2 == 0
        subscript = data % 3 == 2
        result = MaskedArray(data, masks)[subscript]
        answer = MaskedArray(data[subscript], masks[subscript])
        assert result.equals(answer)

    def test_subscript_by_integer_array(self):
        """Return an instance of `MaskedArray` with expected contents.

        Return a copy of the calling object which content is equal to the
        result of making same subscript operator on the content of the calling
        object.

        """
        data = np.arange(10)
        masks = data % 2 == 0
        subscript = np.arange(0, 10, 2)
        result = MaskedArray(data, masks)[subscript]
        answer = MaskedArray(data[subscript], masks[subscript])
        assert result.equals(answer)

    def test_subscript_by_slice(self):
        """Return an instance of `MaskedArray` with expected contents.

        Return a copy of the calling object which content is equal to the
        result of making same subscript operator on the content of the calling
        object.

        """
        data = np.arange(10)
        masks = data % 2 == 0
        result = MaskedArray(data, masks)[1: 9: 2]
        answer = MaskedArray(data[1: 9: 2], masks[1: 9: 2])
        assert result.equals(answer)

    def test_subscript_by_integer_corresponding_to_available_element(self):
        """Return an expected scalar."""
        result = MaskedArray([1, 2], [True, False])[1]
        answer = 2
        assert result == answer

    def test_subscript_by_integer_corresponding_to_na_element(self):
        """Return ``numpy.nan``."""
        result = MaskedArray([1, 2], [True, False])[0]
        assert result is np.nan
